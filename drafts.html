<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Чернетки | Drafts</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <style>
        :root {
            --pixel-font: 'Press Start 2P', cursive;
            --main-font: 'Roboto Mono', monospace;
            --bg-color: #000000;
            --main-color: #0F0; /* Зелений */
            --frame-color: #303030; /* Темно-сірий для рамок */
            --graphite-frame: #505050; /* Графітовий фрейм для арту */
            --white-color: #FFFFFF;
            --input-bg: #111;
            --input-border: #0F0;
        }

        body {
            font-family: var(--main-font);
            background-color: var(--bg-color);
            color: var(--main-color);
            margin: 0;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            overflow-y: auto;
            padding-bottom: 100px; /* Залишаємо місце для кнопки Telegram */
        }

        .section-header {
            font-family: var(--pixel-font);
            font-size: 14px;
            color: var(--white-color);
            text-shadow: 0 0 5px var(--main-color);
            margin-bottom: 10px;
            text-align: center;
        }

        /* --- Input Styles --- */
        textarea, input[type="datetime-local"] {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--input-border);
            background-color: var(--input-bg);
            color: var(--main-color);
            font-family: var(--main-font);
            box-sizing: border-box;
            resize: vertical;
        }

        /* --- Note Section --- */
        .note-container {
            width: 100%;
            max-width: 400px;
        }
        .note-field {
            margin-bottom: 15px;
            border: 1px solid var(--graphite-frame);
            padding: 10px;
            background-color: var(--input-bg);
        }
        .note-field label {
            display: block;
            margin-bottom: 5px;
            color: var(--main-color);
            font-size: 12px;
        }
        .note-field input[type="datetime-local"] {
            margin-top: 5px;
            font-size: 14px;
        }

        /* --- Canvas Section --- */
        #drawing-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 400px;
            width: 100%;
        }

        #pixel-canvas {
            border: 3px solid var(--graphite-frame);
            background-color: var(--frame-color);
            image-rendering: pixelated;
            touch-action: none; /* Відключаємо типову поведінку тачскріна */
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .controls button {
            background-color: var(--main-color);
            color: var(--bg-color);
            border: none;
            padding: 8px 12px;
            font-family: var(--main-font);
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
        }
        
        .color-preview {
            width: 20px;
            height: 20px;
            border: 2px solid var(--white-color);
            display: inline-block;
            vertical-align: middle;
            margin-left: 5px;
        }

    </style>
</head>
<body>

    <div class="note-container">
        <div class="section-header">Замітка та Нагадування</div>
        <div class="note-field">
            <label for="note-text">Текст замітки (збережеться як чернетка)</label>
            <textarea id="note-text" rows="5" placeholder="Введіть текст замітки..."></textarea>
        </div>
        <div class="note-field">
            <label for="reminder-time">Нагадати (UTC час)</label>
            <input type="datetime-local" id="reminder-time">
        </div>
    </div>

    <div id="drawing-area">
        <div class="section-header">Pixel Art (16x16)</div>
        <canvas id="pixel-canvas" width="256" height="256"></canvas>
        <div class="controls">
            <button id="clear-canvas">Очистити</button>
            <input type="color" id="color-picker" value="#FFFFFF">
            <span style="color: var(--white-color); font-size: 12px; line-height: 24px;">Колір</span>
        </div>
    </div>

    <script>
        const tg = window.Telegram.WebApp;
        
        // ===================================
        // === НАЛАШТУВАННЯ CANVAS ===
        // ===================================
        const canvas = document.getElementById('pixel-canvas');
        const ctx = canvas.getContext('2d');
        const colorPicker = document.getElementById('color-picker');
        const clearButton = document.getElementById('clear-canvas');
        
        const GRID_SIZE = 16;
        const PIXEL_SIZE = canvas.width / GRID_SIZE; // 256 / 16 = 16
        
        let currentColor = colorPicker.value;
        let isDrawing = false;

        function initCanvas() {
            // Заповнення фоном
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Налаштування для піксельного малювання
            ctx.imageSmoothingEnabled = false;
        }

        function getCanvasPosition(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function drawPixel(x, y) {
            // Перетворення координат миші/дотику в координати піксельної сітки
            const gridX = Math.floor(x / PIXEL_SIZE);
            const gridY = Math.floor(y / PIXEL_SIZE);

            if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
                ctx.fillStyle = currentColor;
                ctx.fillRect(gridX * PIXEL_SIZE, gridY * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
            }
        }
        
        function draw(e) {
            if (!isDrawing) return;
            const pos = getCanvasPosition(e);
            drawPixel(pos.x, pos.y);
            e.preventDefault(); // Запобігає прокручуванню на мобільних
        }

        // Обробники подій для малювання
        canvas.addEventListener('mousedown', (e) => { isDrawing = true; draw(e); });
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', () => { isDrawing = false; });
        canvas.addEventListener('mouseleave', () => { isDrawing = false; });
        
        // Для мобільних
        canvas.addEventListener('touchstart', (e) => { isDrawing = true; draw(e); }, { passive: false });
        canvas.addEventListener('touchmove', draw, { passive: false });
        canvas.addEventListener('touchend', () => { isDrawing = false; });

        // Обробник зміни кольору
        colorPicker.addEventListener('input', (e) => {
            currentColor = e.target.value;
        });

        // Обробник очищення
        clearButton.addEventListener('click', initCanvas);

        // ===================================
        // === ВІДПРАВКА ДАНИХ БОТУ ===
        // ===================================
        
        function initApp() {
            tg.ready();
            tg.MainButton.setText("ЗБЕРЕГТИ ЧЕРНЕТКИ");
            tg.MainButton.show();
            initCanvas(); // Ініціалізуємо полотно
            
            // Встановлюємо мінімальний час для нагадування (поточний час)
            const now = new Date();
            const offset = now.getTimezoneOffset() * 60000;
            const localISOTime = (new Date(now - offset)).toISOString().slice(0, 16);
            document.getElementById('reminder-time').min = localISOTime;
        }

        tg.onEvent('mainButtonClicked', function() {
            const dataToSend = {
                notes: [],
                arts: []
            };
            
            // 1. Обробка Нотатки та Нагадування
            const noteText = document.getElementById('note-text').value.trim();
            const reminderTimeLocal = document.getElementById('reminder-time').value;

            if (noteText) {
                const noteData = {
                    text: noteText,
                    reminder: null
                };
                
                if (reminderTimeLocal) {
                    // Конвертуємо локальний час у ISO 8601 UTC (додаємо 'Z')
                    const date = new Date(reminderTimeLocal);
                    if (!isNaN(date)) {
                        noteData.reminder = date.toISOString();
                    }
                }
                
                dataToSend.notes.push(noteData);
            }

            // 2. Обробка Піксель Арту
            // Отримуємо Base64 рядок зображення без префікса "data:image/png;base64,"
            const imageDataURL = canvas.toDataURL('image/png');
            const base64Image = imageDataURL.split(',')[1];
            
            // Перевіряємо, чи полотно не порожнє (хоча б один піксель відрізняється від фону #111)
            // Оскільки ми не можемо легко визначити, чи полотно "порожнє" після заливки фоном,
            // відправляємо його завжди, якщо користувач натиснув "Зберегти"
            // Альтернативно, можна перевірити, чи картинка відрізняється від пустої, але це складніше.
            // Припустимо, що користувач хоче зберегти навіть чорний квадрат.
            
            // Якщо полотно не ініціалізовано фоном #111 (наприклад, після очищення), може бути прозорий.
            // Ми завжди ініціалізуємо його чорним, тому просто відправляємо.
            
            dataToSend.arts.push({
                image: base64Image
            });

            // Надсилаємо JSON дані боту
            tg.sendData(JSON.stringify(dataToSend));
        });

        // --- Запуск --
        initApp();
    </script>
</body>
</html>